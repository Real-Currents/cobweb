<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.3//EN" "http://www.web3d.org/specifications/x3d-3.3.dtd">
<X3D profile='Full' version='3.3' xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.3.xsd'>
  <head>
    <meta name='comment' content='World of Titania'/>
    <meta name='created' content='Tue, 11 Apr 2017 00:24:19 GMT'/>
    <meta name='creator' content='Holger Seelig'/>
    <meta name='generator' content='Titania V3.0.1, http://titania.create3000.de'/>
    <meta name='identifier' content='file:///home/holger/Projekte/Cobweb/cobweb.js/tests/Components/Shaders/Waves.x3d'/>
    <meta name='modified' content='Tue, 11 Apr 2017 03:32:33 GMT'/>
    <meta name='outputStyle' content='Nicest'/>
  </head>
  <Scene>
    <WorldInfo>
      <MetadataSet DEF='Titania'
          name='Titania'
          reference='http://titania.create3000.de'>
        <MetadataSet DEF='AngleGrid' containerField='value'
            name='AngleGrid'
            reference='http://titania.create3000.de'>
          <MetadataBoolean DEF='enabled' containerField='value'
              name='enabled'
              reference='http://titania.create3000.de'
              value='false'/>
        </MetadataSet>
        <MetadataSet DEF='Grid' containerField='value'
            name='Grid'
            reference='http://titania.create3000.de'>
          <MetadataBoolean DEF='enabled_1' containerField='value'
              name='enabled'
              reference='http://titania.create3000.de'
              value='false'/>
        </MetadataSet>
        <MetadataSet DEF='NavigationInfo' containerField='value'
            name='NavigationInfo'
            reference='http://titania.create3000.de'>
          <MetadataString DEF='type' containerField='value'
              name='type'
              reference='http://titania.create3000.de'
              value='"EXAMINE"'/>
        </MetadataSet>
        <MetadataSet DEF='Viewpoint' containerField='value'
            name='Viewpoint'
            reference='http://titania.create3000.de'>
          <MetadataDouble DEF='position' containerField='value'
              name='position'
              reference='http://titania.create3000.de'
              value='0, 0, 10'/>
          <MetadataDouble DEF='orientation' containerField='value'
              name='orientation'
              reference='http://titania.create3000.de'
              value='0, 0, 1, 0'/>
          <MetadataDouble DEF='centerOfRotation' containerField='value'
              name='centerOfRotation'
              reference='http://titania.create3000.de'
              value='0, 0, 0'/>
        </MetadataSet>
        <MetadataSet DEF='Selection' containerField='value'
            name='Selection'
            reference='http://titania.create3000.de'>
          <MetadataSet DEF='previous' containerField='value'
              name='previous'
              reference='http://titania.create3000.de'>
            <LayoutLayer DEF='_1' containerField='value'>
              <Layout
                  size='1'/>
              <NavigationInfo
                  type='"NONE"'/>
              <TimeSensor DEF='Timer'
                  cycleInterval='1000'
                  loop='true'/>
              <ScalarInterpolator DEF='_2'
                  key='0, 1'
                  keyValue='0, 1000'/>
              <Transform DEF='ElevationGrid'>
                <Shape>
                  <Appearance>
                    <Material/>
                    <ComposedShader DEF='WaterShader'
                        language='GLSL'>
                      <field accessType='inputOutput' type='SFFloat' name='time' value='33.1004'/>
                      <field accessType='inputOutput' type='SFColor' name='diffuse' value='0.1 0.1 0.1'/>
                      <field accessType='inputOutput' type='SFFloat' name='specular' value='8'/>
                      <field accessType='inputOutput' type='SFFloat' name='specularHardness' value='512'/>
                      <field accessType='inputOutput' type='SFBool' name='postEffects' value='true'/>
                      <field accessType='inputOutput' type='SFBool' name='moveCamera' value='true'/>
                      <field accessType='inputOutput' type='SFBool' name='reflections' value='true'/>
                      <field accessType='inputOutput' type='SFFloat' name='seaHeight' value='-0.5'/>
                      <field accessType='inputOutput' type='SFVec3f' name='cameraPos' value='0 5 0'/>
                      <field accessType='inputOutput' type='SFVec3f' name='cameraLookat' value='-125 -100 -95'/>
                      <field accessType='inputOutput' type='SFVec3f' name='lightDir' value='-1 0.8 -1'/>
                      <field accessType='inputOutput' type='SFVec3f' name='lightColour' value='0.7 0.8 0.9'/>
                      <ShaderPart DEF='WaterVertexShader'>
<![CDATA[data:text/plain,

precision mediump float;

uniform mat4 x3d_ProjectionMatrix;
uniform mat4 x3d_ModelViewMatrix;

attribute vec4 x3d_Vertex;

varying vec4 vertex;

void main ()
{
	vertex = x3d_ModelViewMatrix * x3d_Vertex;

	gl_Position = x3d_ProjectionMatrix * vertex;
}
]]>
                      </ShaderPart>
                      <ShaderPart DEF='WaterFragmentShader'
                          type='FRAGMENT'>
<![CDATA[data:text/plain,

#ifdef GL_ES
precision highp float;
#endif

uniform float time;
uniform vec3 cameraPos;
uniform vec3 cameraLookat;
uniform vec3 lightDir;
uniform vec3 lightColour;
uniform float specular;
uniform float specularHardness;
uniform vec3 diffuse;
uniform bool postEffects;
uniform bool moveCamera;
uniform bool reflections;
uniform float seaHeight;

uniform ivec4 x3d_Viewport;

vec2 resolution = vec2 (x3d_Viewport .zw);

#define GAMMA 0.8
#define CONTRAST 1.1
#define SATURATION 1.3
#define BRIGHTNESS 1.3
#define RAY_DEPTH 64
#define MAX_DEPTH 200.0
#define DISTANCE_MIN 0.001
#define PI 3.14159265

const vec2 delta = vec2(DISTANCE_MIN, 0.);

float Hash(in float n)
{
    return fract(sin(n)*43758.5453123);
}

float Noise(in vec2 x)
{
    vec2 p = floor(x);
    vec2 f = fract(x);
    f = f*f*(3.0-2.0*f);
    float n = p.x + p.y*57.0;
    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),
                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);
    return res;
}

// Octave transform matrix from Alexander Alekseev aka TDM 
mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);

float FractalNoise(in vec2 xy)
{
   float m = 1.5;
   float w = 0.5;
   float f = 0.0;
   for (int i = 0; i < 6; i++)
   {
      f += Noise(xy+time*0.511) * m * 0.15;
      f += Noise(xy.yx-time*0.333) * w * 0.25;
      w *= 0.5;
      m *= 0.25;
      xy *= octave_m;
   }
   return f;
}

// This should return continuous positive values when outside and negative values inside,
// which roughly indicate the distance of the nearest surface.
float Dist(vec3 pos)
{
   return dot(pos-vec3(0.,-FractalNoise(pos.xz),0.), vec3(0.,1.,0.));
}

vec3 GetNormal(vec3 pos)
{
   vec3 n;
   n.x = Dist( pos + delta.xyy ) - Dist( pos - delta.xyy );
   n.y = Dist( pos + delta.yxy ) - Dist( pos - delta.yxy );
   n.z = Dist( pos + delta.yyx ) - Dist( pos - delta.yyx );
   
   return normalize(n);
}

// Original method by David Hoskins
vec3 Sky(in vec3 rd)
{
   float sunAmount = max(dot(rd, lightDir), 0.0);
   float v = pow(1.0 - max(rd.y,0.0),6.);
   vec3 sky = mix(vec3(.1, .2, .4), vec3(.32, .32, .32), v);
   sky += lightColour * sunAmount * sunAmount * .25 + lightColour * min(pow(sunAmount, 800.0)*1.5, .3);
   
   return clamp(sky, 0.0, 1.0);
}

// Fog routine - original by IQ
vec3 Fog(vec3 rgb, vec3 rd, float distance)   // camera to point distance
{
   const float b = 0.10;
   float fogAmount = 1.0 - exp(-distance*b*b);
   vec3  fogColor = Sky(rd);
   return mix(rgb, fogColor, fogAmount);
}

const vec3 WATER_COLOR = vec3(0.6,0.9,0.6);
vec3 Shading(vec3 pos, vec3 rd, vec3 norm, vec3 ro)
{
   vec3 light = lightColour * max(0.0, dot(norm, lightDir));
   vec3 view = normalize(-rd);
   vec3 heading = normalize(view + lightDir);
   float spec = pow(max(0.0, dot(heading, norm)), specularHardness);
   
   float fresnel = 0.0;
   if (reflections)
   {
      fresnel = pow(1.0 - dot(view, norm), 5.0);
      fresnel = mix(0.0, 1.0, min(1.0, fresnel));
   }
   
   light = (diffuse * light) + (spec * specular * lightColour) * (1.0-fresnel);
   
   if (fresnel > 0.0)
   {
      vec3 refrd = reflect(rd, norm);
      light += Sky(refrd) * fresnel;
   }
   
   // attenuation
   vec3 dist = pos - ro;
   float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);
   light += WATER_COLOR * (pos.y - seaHeight) * 0.20 * atten;
   
   light = Fog(light, rd, length(ro-pos));
   
   return light;
}

// Original method by David Hoskins
vec3 PostEffects(vec3 rgb, vec2 xy)
{
   rgb = pow(rgb, vec3(GAMMA));
   rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);
   rgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 ); 
   return rgb;
}

// Camera function by TekF
// Compute ray from camera parameters
vec3 GetRay(vec3 dir, vec2 pos)
{
   pos = pos - 0.5;
   pos.x *= resolution.x/resolution.y;
   
   dir = normalize(dir);
   vec3 right = normalize(cross(vec3(0.,1.,0.),dir));
   vec3 up = normalize(cross(dir,right));
   
   return dir + right*pos.x + up*pos.y;
}

vec4 March(vec3 ro, vec3 rd)
{
   float t = 0.0;
   float d = 1.0;
   for (int i=0; i<RAY_DEPTH; i++)
   {
      vec3 p = ro + rd * t;
      d = Dist(p);
      if (abs(d) < DISTANCE_MIN)
      {
         return vec4(p, 1.0);
      }
      t += d;
      if (t >= MAX_DEPTH) break;
   }
   return vec4(0.0);
}

void main()
{
   vec3 off = vec3(0.0);
   if (moveCamera) off.z -= time*0.5;
   
   vec2 p = gl_FragCoord.xy / resolution.xy;
   vec3 ro = cameraPos + off;
   vec3 rd = normalize(GetRay((cameraLookat-off)-cameraPos+off, p));
   
   vec4 res = March(ro, rd);
   if (res.a == 1.0) res.rgb = Shading(res.rgb, rd, GetNormal(res.rgb), ro).rgb;
   else res.rgb = Sky(rd);
   if (postEffects) res.rgb = PostEffects(res.rgb, p);
   
   gl_FragColor = vec4(res.rgb, 1.0);
}
]]>
                      </ShaderPart>
                    </ComposedShader>
                  </Appearance>
                  <Rectangle2D
                      size='1 1'
                      solid='false'/>
                </Shape>
              </Transform>
            </LayoutLayer>
          </MetadataSet>
          <MetadataSet DEF='nodes' containerField='value'
              name='nodes'
              reference='http://titania.create3000.de'>
            <ComposedShader USE='WaterShader' containerField='value'/>
          </MetadataSet>
        </MetadataSet>
        <MetadataSet DEF='AxonometricGrid' containerField='value'
            name='AxonometricGrid'
            reference='http://titania.create3000.de'>
          <MetadataBoolean DEF='enabled_2' containerField='value'
              name='enabled'
              reference='http://titania.create3000.de'
              value='false'/>
        </MetadataSet>
        <MetadataSet DEF='LayerSet' containerField='value'
            name='LayerSet'
            reference='http://titania.create3000.de'>
          <MetadataInteger DEF='activeLayer' containerField='value'
              name='activeLayer'
              reference='http://titania.create3000.de'
              value='-1'/>
        </MetadataSet>
      </MetadataSet>
    </WorldInfo>
    <LayerSet
        order='1'>
      <LayoutLayer USE='_1'/>
    </LayerSet>
    <ROUTE fromNode='_2' fromField='value_changed' toNode='WaterShader' toField='set_time'/>
    <ROUTE fromNode='Timer' fromField='fraction_changed' toNode='_2' toField='set_fraction'/>
  </Scene>
</X3D>
